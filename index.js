const express = require('express');
const { spawn } = require('child_process');
const fs = require('fs');

const app = express();
const PORT = process.env.PORT || 3000;

// Tuner Configuration
// Adjust these adapter paths based on your system (e.g., /dev/dvb/adapter0, /dev/dvb/adapter1)
const TUNERS = [
    { id: 0, adapter: '/dev/dvb/adapter0', inUse: false },
    { id: 1, adapter: '/dev/dvb/adapter1', inUse: false }
];

// Mock Channel List - Replace with actual frequency data
const CHANNELS = [
    { number: '45.1', name: 'WFWC-CD', serviceId: 1001 },
    { number: '45.2', name: 'WFWC-CD', serviceId: 1002 },
    { number: '45.3', name: 'WFWC-CD', serviceId: 1003 },
    { number: '45.4', name: 'WFWC-CD', serviceId: 1004 },
    { number: '45.5', name: 'WFWC-CD', serviceId: 1005 },
    { number: '45.6', name: 'WFWC-CD', serviceId: 1006 },
    { number: '45.7', name: 'WFWC-CD', serviceId: 1007 },
    { number: '45.8', name: 'WFWC-CD', serviceId: 1008 },
    { number: '38.1', name: 'WEIJ HD', serviceId: 3 },
    { number: '38.4', name: 'COZI TV', serviceId: 6 },
    { number: '38.2', name: 'SBN', serviceId: 4 },
    { number: '38.8', name: 'QUEST', serviceId: 10 },
    { number: '38.5', name: 'IONPLUS', serviceId: 7 },
    { number: '38.9', name: 'ONTV4U', serviceId: 11 },
    { number: '38.7', name: 'TOONS', serviceId: 9 },
    { number: '38.10', name: 'BIZ TV', serviceId: 12 },
    { number: '38.3', name: 'WEST', serviceId: 5 },
    { number: '38.6', name: 'JTV', serviceId: 8 },
    { number: '38.11', name: 'GDT', serviceId: 13 },
    { number: '39.1', name: 'PBS FW', serviceId: 1 },
    { number: '39.2', name: 'PBSKIDS', serviceId: 2 },
    { number: '39.3', name: 'CREATE', serviceId: 3 },
    { number: '39.4', name: 'World', serviceId: 4 },
    { number: '39.5', name: 'PBS WX', serviceId: 5 },
    { number: '39.6', name: 'PBS ARS', serviceId: 6 },
    { number: '55.1', name: 'WFFT-TV', serviceId: 3 },
    { number: '55.2', name: 'Bounce', serviceId: 4 },
    { number: '55.3', name: 'Antenna', serviceId: 5 },
    { number: '16.1', name: 'WCUH-LD', serviceId: 1001 },
    { number: '16.2', name: 'WCUH-LD', serviceId: 1002 },
    { number: '16.3', name: 'WCUH-LD', serviceId: 1003 },
    { number: '16.4', name: 'WCUH-LD', serviceId: 1004 },
    { number: '16.5', name: 'WCUH-LD', serviceId: 1005 },
    { number: '16.6', name: 'WCUH-LD', serviceId: 1006 },
    { number: '16.7', name: 'WCUH-LD', serviceId: 1007 },
    { number: '21.1', name: 'WPTAABC', serviceId: 1 },
    { number: '21.2', name: 'WPTANBC', serviceId: 2 },
    { number: '21.3', name: 'WPTAMY', serviceId: 3 },
    { number: '15.1', name: 'WANE-HD', serviceId: 3 },
    { number: '15.2', name: 'ION', serviceId: 4 },
    { number: '15.3', name: 'LAFF', serviceId: 5 },
    { number: '15.4', name: 'Escape', serviceId: 6 },
    { number: '33.1', name: 'WISECW', serviceId: 1 },
    { number: '33.2', name: 'Justice', serviceId: 2 },
    { number: '33.3', name: 'Grit', serviceId: 3 },
    { number: '33.4', name: 'CourtTV', serviceId: 4 },
    { number: '33.5', name: 'Start', serviceId: 5 },
    { number: '33.6', name: 'MeTV', serviceId: 6 },
    { number: '33.7', name: 'DABL', serviceId: 7 }
];

// Helper to get an available tuner
function getFreeTuner() {
    return TUNERS.find(t => !t.inUse);
}

// Helper: Promise-based delay
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

// Helper: WaitForTuner with timeout
async function waitForTuner(maxRetries = 10, interval = 500) {
    for (let i = 0; i < maxRetries; i++) {
        const tuner = getFreeTuner();
        if (tuner) return tuner;
        console.log(`No tuners available, waiting... (${i + 1}/${maxRetries})`);
        await delay(interval);
    }
    return null;
}

// Generate M3U Playlist
app.get('/lineup.m3u', (req, res) => {
    let m3u = '#EXTM3U\n';
    const host = req.headers.host;

    CHANNELS.forEach(channel => {
        m3u += `#EXTINF:-1 tvg-id="${channel.number}" tvg-name="${channel.name}",${channel.name}\n`;
        m3u += `http://${host}/stream/${channel.number}\n`;
    });

    res.set('Content-Type', 'audio/x-mpegurl');
    res.send(m3u);
});

// Stream Endpoint
app.get('/stream/:channelNum', async (req, res) => {
    const channelNum = req.params.channelNum;
    const channel = CHANNELS.find(c => c.number === channelNum);

    if (!channel) {
        return res.status(404).send('Channel not found');
    }

    // Attempt to get a tuner, waiting up to 5 seconds if busy
    // This allows time for the previous stream's cleanup to complete during a channel change
    const tuner = await waitForTuner();

    if (!tuner) {
        return res.status(503).send('No tuners available');
    }

    console.log(`Starting stream for ${channel.name} on Tuner ${tuner.id}`);
    tuner.inUse = true;
    tuner.processes = {};

    // Path to your dvb channel configuration file (generated by dvbv5-scan)
    const CHANNELS_CONF = process.env.CHANNELS_CONF || '/etc/dvb/channels.conf';

    // 1. Start dvbv5-zap to tune the frontend
    // Arguments:
    // -c : configuration file
    // -r : set up /dev/dvb/adapterX/dvr0 for recording/streaming
    // -a : adapter index
    // <channel_name> : exact name from the config file
    const zap = spawn('dvbv5-zap', [
        '-c', CHANNELS_CONF,
        '-r',
        '-a', tuner.id,
        channel.name
    ]);
    tuner.processes.zap = zap;

    zap.on('error', (err) => {
        console.error(`Tuner ${tuner.id} zap error:`, err);
        // If zap fails to start, cleanup immediately
        cleanup();
        if (!res.headersSent) res.status(500).send('Tuner error');
    });

    // Wait slightly for lock? Or just start ffmpeg immediately. 
    // Usually safe to start ffmpeg immediately as it will block on reading dvr0 until data arrives.

    // 2. Start ffmpeg to read from dvr0 and pipe to response
    const dvrPath = `${tuner.adapter}/dvr0`;

    // FFmpeg options:
    // -i : input path
    // -map 0:p:<serviceId> : Select the specific program/service ID from the TS
    // -c copy : copy stream
    // -f mpegts : output format
    const ffmpegArgs = [
        '-analyzeduration', '1000000',
        '-probesize', '1000000',
        '-i', dvrPath,
    ];

    if (channel.serviceId) {
        console.log(`Filtering for Service ID: ${channel.serviceId}`);
        // Map the specific program ID. 
        // Syntax often is -map 0:p:<program_id> or just relying on the player to pick if we send all.
        // But since you said 45.1 plays when 45.2 is asked, we are sending both and player picks first.
        // We need to valid stream mapping. 
        // ffmpeg -i input.ts -map 0:p:1001 -c copy ...
        ffmpegArgs.push('-map', `0:p:${channel.serviceId}`);
        // Note: some ffmpeg versions use -map 0:m:program_id or similar. '0:p:ID' is standard for program mapping.
    }

    ffmpegArgs.push(
        '-c', 'copy',
        '-f', 'mpegts',
        'pipe:1'
    );

    const ffmpeg = spawn('ffmpeg', ffmpegArgs);
    tuner.processes.ffmpeg = ffmpeg;

    res.writeHead(200, {
        'Content-Type': 'video/mp2t',
        'Connection': 'keep-alive'
    });

    // Handle ffmpeg output pipe errors (e.g. client disconnect)
    ffmpeg.stdout.on('error', (err) => {
        if (err.code === 'EPIPE' || err.code === 'ECONNRESET') {
            console.log(`FFmpeg EPIPE/ECONNRESET [Tuner ${tuner.id}] - client likely disconnected`);
            cleanup();
        } else {
            console.error(`FFmpeg stdout error [Tuner ${tuner.id}]:`, err);
        }
    });

    ffmpeg.stdout.pipe(res).on('error', (err) => {
        console.warn(`Response pipe error [Tuner ${tuner.id}]:`, err);
        cleanup();
    });

    // Logging helpers
    ffmpeg.stderr.on('data', (data) => console.log(`FFmpeg [Tuner ${tuner.id}]: ${data}`));
    zap.stderr.on('data', (data) => console.log(`Zap [Tuner ${tuner.id}]: ${data}`));

    // Cleanup function
    const cleanup = () => {
        if (tuner.cleaningUp) return;
        tuner.cleaningUp = true;

        console.log(`Cleaning up Tuner ${tuner.id}`);

        // Kill processes
        zap.kill('SIGTERM');
        ffmpeg.kill('SIGTERM');

        // Safety timeout to force release if processes hang
        const forceReleaseTimeout = setTimeout(() => {
            console.warn(`Force releasing Tuner ${tuner.id} after timeout`);
            try { zap.kill('SIGKILL'); } catch (e) { }
            try { ffmpeg.kill('SIGKILL'); } catch (e) { }
            // We'll let the exit handlers do the final state update if possible
        }, 2000);

        // Allow one final clearing of timeout if zap exits cleanly before timeout
        tuner.forceReleaseTimeout = forceReleaseTimeout;
    };

    // release tuner only when zap exits (lock released)
    zap.on('exit', (code, signal) => {
        console.log(`Zap exited [Tuner ${tuner.id}] (code: ${code}, signal: ${signal})`);

        if (tuner.forceReleaseTimeout) {
            clearTimeout(tuner.forceReleaseTimeout);
            tuner.forceReleaseTimeout = null;
        }

        // Always mark free on zap exit, as the hardware lock is definitely gone
        tuner.inUse = false;
        tuner.cleaningUp = false;
        console.log(`Tuner ${tuner.id} marked as FREE`);
    });

    ffmpeg.on('exit', (code) => {
        console.log(`FFmpeg exited [Tuner ${tuner.id}] with code ${code}`);
        // If ffmpeg dies, we must kill zap to stop tuning
        cleanup();
    });

    // Client disconnect
    req.on('close', () => {
        console.log(`Client disconnected [Tuner ${tuner.id}]`);
        cleanup();
    });

    // Handle zap errors
    zap.on('error', (err) => {
        console.error(`Tuner ${tuner.id} zap error:`, err);
        cleanup();
    });
});

app.listen(PORT, () => {
    console.log(`Tuner app listening at http://localhost:${PORT}`);
});

// Global Cleanup on App Exit
function cleanExit() {
    console.log('\nApp stopping, ensuring all tuners are released...');
    TUNERS.forEach(tuner => {
        if (tuner.inUse && tuner.processes) {
            console.log(`Killing processes for Tuner ${tuner.id}`);
            if (tuner.processes.zap) try { tuner.processes.zap.kill('SIGKILL'); } catch (e) { }
            if (tuner.processes.ffmpeg) try { tuner.processes.ffmpeg.kill('SIGKILL'); } catch (e) { }
        }
    });
    process.exit();
}

process.on('SIGINT', cleanExit);
process.on('SIGTERM', cleanExit);
